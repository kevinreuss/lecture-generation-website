<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Shader Programming in Graphics</title>
    <!-- Markdown Parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <style>
      .markdown-content {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
      }
      pre code {
        border-radius: 4px;
        padding: 1em;
        background-color: #f6f8fa;
        display: block;
        overflow-x: auto;
      }
      h1, h2, h3 {
        color: #24292e;
        margin-top: 24px;
        margin-bottom: 16px;
      }
      a {
        color: #0366d6;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      #markdown-content {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="content" class="markdown-content"></div>
    <!-- Markdown Content -->
    <textarea id="markdown-content">
# Shader Programming in Graphics

Shader programming is an essential part of graphics rendering. Shaders are small programs that run on the GPU and perform operations on vertices and pixel data. There are two main types of shaders: Vertex Shaders and Fragment (Pixel) Shaders.

- **Vertex Shaders** operate on each vertex of a mesh and generally handle transformations, such as moving vertices in 3D space, or applying per-vertex lighting calculations.

```C++
// Simple vertex shader in GLSL
#version 330 core
layout (location = 0) in vec3 aPos;
void main()
{
   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
```

- **Fragment Shaders** take the outputs of the vertex shader and generate the final color of a pixel. This is often where textures are applied, and per-pixel lighting calculations are performed.

```C++
// Simple fragment shader in GLSL
#version 330 core
out vec4 FragColor;
void main()
{
   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}
```

Shader programs are written in specialized languages like GLSL (OpenGL Shading Language), HLSL (High-Level Shading Language for DirectX), or SPIR-V (for Vulkan and OpenCL). 

Modern shader programming also includes Geometry Shaders, Tessellation Shaders, and Compute Shaders, allowing for more complex operations on the GPU. For example, Geometry Shaders can generate new geometry on the fly, and Compute Shaders can perform general purpose computations.

Understanding how to write and optimize shaders is key to achieving high performance graphics rendering. By offloading computations to the GPU, you can achieve real-time rendering of complex scenes, advanced lighting and post-processing effects, and more.
    </textarea>
    <!-- Main Script -->
    <script>
      const markdown = document.getElementById("markdown-content").value;
      marked.setOptions({
        breaks: true,
        gfm: true,
        headerIds: true,
        highlight: function (code, lang) {
          if (lang && hljs.getLanguage(lang)) {
            return hljs.highlight(code, { language: lang }).value;
          }
          return hljs.highlightAuto(code).value;
        },
      });
      document.getElementById("content").innerHTML = marked.parse(markdown);
      hljs.highlightAll();
    </script>
  </body>
</html>